;	skeletal cbios for first level of CP/M 2.0 alteration
;
msize	EQU	62	;cp/m version memory size in kilobytes
;
;	"bias" is address offset from 3400h for memory systems
;	than 16k (referred to as"b" throughout the text)
;
bias	EQU	(MSIZE-20)*1024
ccp		EQU	3400H+BIAS	;base of ccp
bdos	EQU	CCP+806H	;base of bdos
bios	EQU	CCP+1600H	;base of bios
cdisk	EQU	0004H	;current disk number 0=a,... l5=p
iobyte	EQU	0003H	;intel i/o byte
;

;
; SIO I/O ports
;
SIOAD EQU 0F8H
SIOAC EQU 0F9H

;
; FDC I/O ports
;
FDC_COMMAND_REG EQU 0C8H
FDC_STATUS_REG  EQU FDC_COMMAND_REG
FDC_TRACK_REG   EQU 0C9H
FDC_SECTOR_REG  EQU 0CAH
FDC_DATA_REG    EQU 0CBH
DMA_ADDRESS     EQU 0CCH
FDC_CONTROL_REG EQU 0CDH
DMA_BANK_SEL 	EQU 0CEH


;
; CRTC ports
;
VRAM_TXT_TOP EQU 0F800H
VRAM_ATR_TOP EQU 0F000H
CRTC_ADD EQU 0F0H
CRTC_VAL EQU 0F1H
WIDTH_SCREEN EQU 50H

;;; Ascii code Constants
CR	EQU	0DH
LF	EQU	0AH
BS	EQU	08H
DEL	EQU	7FH


;;; Keyboard scan buffer
;;; キーボードスキャンの実装上、末尾のアドレスが00であることが条件になっている。
KEYBOARD_SCAN_BUFFER EQU 0FE00H


;
;*****************************************************
;*                                                   *
;*         CP/M to host disk constants               *
;*                                                   *
;*****************************************************
blksiz equ 2048	;CP/M allocation size
hstsiz equ 256	;host disk sector size
hstspt equ 26	;host disk sectors/trk
hstblk equ hstsiz/128	;CP/M sects/host buff
cpmspt equ hstblk * hstspt	;CP/M sectors/track
secmsk equ hstblk-1	;sector mask
;smask	hstblk	;compute sector mask
secshf equ 1	;log2(hstblk)
;
;*****************************************************
;*                                                   *
;*        BDOS constants on entry to write           *
;*                                                   *
;*****************************************************
wrall equ 0	;write to allocated
wrdir equ 1	;write to directory
wrual equ 2	;write to unallocated

		ORG	BIOS	;origin of this program
nsects	EQU	($-CCP)/128	;warm start sector count
;
;	jump vector for individual subroutines
;
		JP	boot	;cold start
wboote:	JP	wboot	;warm start
		JP	const	;console status
		JP	conin	;console character in
		JP	conout	;console character out
		JP	list	;list character out
		JP	punch	;punch character out
		JP	reader	;reader character out
		JP	home	;move head to home position
		JP	seldsk	;select disk
		JP	settrk	;set track number
		JP	setsec	;set sector number
		JP	setdma	;set dma address
		JP	read	;read disk
		JP	write	;write disk
		JP	listst	;return list status
		JP	sectran	;sector translate
;
;	fixed data tables for four-drive standard
;	ibm-compatible 8" disks
;
;	disk Parameter header for disk 00
dpbase:	dw	XLT0, 0000h
		dw	0000h, 0000h
		dw	dirbf, dpblk
		dw	chk00, all00
;	disk parameter header for disk 01
		dw	XLT0, 0000h
		dw	0000h, 0000h
		dw	dirbf, dpblk
		dw	chk01, all01
;	disk parameter header for disk 02
		dw	XLT0, 0000h
		dw	0000h, 0000h
		dw	dirbf, dpblk
		dw	chk02, all02
;	disk parameter header for disk 03
		dw	XLT0, 0000h
		dw	0000h, 0000h
		dw	dirbf, dpblk
		dw	chk03, all03
;
;	sector translate vector
XLT0	EQU	0		;NO XLATE TABLE

;
; SORD M68 2HD 77 track, 26 sector, 256 byte/sector, 2side, 4096 data block
;
;
dpblk:	;DISK PARM BLOCK
		DW	52		;SEC PER TRACK
		DB	5		;BLOCK SHIFT
		DB	31		;BLOCK MASK
		DB	3		;EXTNT MASK
		DW	242		;DISK SIZE-1
		DW	127		;DIRECTORY MAX
		DB	128		;ALLOC0
		DB	0		;ALLOC1
		DW	32		;CHECK SIZE
		DW	2		;OFFSET
;
;	end of fixed tables
;
;	individual subroutines to perform each function
boot:	;simplest case is to just perform parameter initialization
		XOR	A	;zero in the accum
		LD	(iobyte),A	;clear the iobyte
		LD	(cdisk),A	;select disk zero
		LD	(hstact),A	;host buffer inactive
		LD	(unacnt),A	;clear unalloc count
		CALL SIO_INIT
		CALL CRT_INIT
		CALL KBD_INIT
		PUSH AF
		PUSH HL
		LD HL,OPENMSG
		CALL STROUT
		POP HL
		POP AF
		JP	gocpm	;initialize and go to cp/m
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; worm boot process
;
wboot:	;simplest case is to read the disk until all sectors loaded

		; WBOOTでは、CPPとBDOSをディスクから再ロードする。
		; BIOSはロードしない（すると壊れる）。

		LD	SP, FF80h	;use space below buffer for stack
		LD	C, 0	;select disk 0
		CALL seldsk
		CALL RESTORE ; HEAD move to track 00

		; FDC initialize
		LD A,04H ; 
		CALL FDC_CONTROL_OUT

		; DMA Bank Selectを0に設定
		XOR A ; A=0
		OUT (DMA_BANK_SEL), A

		; DMAの転送アドレスを62k memory modelにおけるccpのアドレス(DC00H)にセットする。

		LD A,0DCH ; DC00Hは62K memory model
		LD (wboot_add),A

		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; 1st READ
		; 現在は、トラック7、Side 0、セクタ13～26からトラック7、Side 1、セクタ1～18という
		; 中途半端な位置にCPM.SYSを配置している。wbootではBIOSを除いた1600H分読み込むこと。つまり22セクタ分
		;
		LD D,04H
		LD E,07H ; TARGET TRACK is No.7
DO_SEEK_WBOOT0:
		CALL SEEK
		JR Z,GO_DMA_WBOOT0
		JR DO_SEEK_WBOOT0
GO_DMA_WBOOT0:
		LD B,14 ; LOOP COUNT is 0EH(14) sectors
		LD D,04H ; FDCCONTROL COMMAND is Side 0 & High density mode
		LD C,13 ; INITIAL SECTOR NO. is 0DH(13) to 26 sector reading
;
READ_LOOP_WBOOT0:
		CALL GO_DMA_AND_READ_WBOOT0
		INC C
		LD A,(wboot_add) ; memory address of DMA transfer address
		INC A ; 256 byte incriment
		LD (wboot_add),A
		DJNZ READ_LOOP_WBOOT0

		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		; 2nd READ
		;
		;
		; SEEK
		;
		LD E,07H  ; TARGET TRACK No.7
		; FDC \DDENS setting
		LD D,24H ; Side 1 & High density mode
	;	LD D,4H ; Side 0 & High density mode
	;	LD D,44H ; Side 0 & LOW density mode
	;

DO_SEEK_WBOOT1:
		CALL SEEK
		JR Z,GO_DMA_WBOOT1
		JR DO_SEEK_WBOOT1
GO_DMA_WBOOT1:
		LD D,24H ; FDCCONTROL COMMAND is side 1 & High density mode
		LD C,01 ; INITIAL SECTOR NO. is 1 to 08H(8) sector reading. total 22 sector read.
		LD B,08 ; LOOP COUNT is 08H(8) sectors
;
READ_LOOP_WBOOT1:
		CALL GO_DMA_AND_READ_WBOOT1
		INC C
		LD A,(wboot_add) ; memory address of DMA transfer address
		INC A ; 256 byte incriment
		LD (wboot_add),A
		DJNZ READ_LOOP_WBOOT1

		JP gocpm ; CP/Mを再起動

; wboot:	;simplest case is to read the disk until all sectors loaded
; 		LD	SP, 80h	;use space below buffer for stack
; 		LD	C, 0	;select disk 0
; 		CALL	seldsk
; 		CALL	home	;go to track 00
; ;
; 		LD	B, nsects	;b counts * of sectors to load
; 		LD	C, 0	;c has the current track number
; 		LD	D, 2	;d has the next sector to read
; ;	note that we begin by reading track 0, sector 2 since sector 1
; ;	contains the cold start loader, which is skipped in a warm start
; 		LD	HL, ccp	;base of cp/m (initial load point)
; load1:	;load	one more sector
; 		PUSH	BC	;save sector count, current track
; 		PUSH	DE	;save next sector to read
; 		PUSH	HL	;save dma address
; 		LD	C, D	;get sector address to register C
; 		CALL	setsec	;set sector address from register C
; 		POP	BC	;recall dma address to b, C
; 		PUSH	BC	;replace on stack for later recall
; 		CALL	setdma	;set dma address from b, C
; ;
; ;	drive set to 0, track set, sector set, dma address set
; 		CALL	read
; 		CP	00h	;any errors?
; 		JP	NZ,wboot	;retry the entire boot if an error occurs
; ;
; ;	no error, move to next sector
; 		POP	HL	;recall dma address
; 		LD	DE, 128	;dma=dma+128
; 		ADD	HL,DE	;new dma address is in h, l
; 		POP	DE	;recall sector address
; 		POP	BC	;recall number of sectors remaining, and current trk
; 		DEC	B	;sectors=sectors-1
; 		JP	Z,gocpm	;transfer to cp/m if all have been loaded
; ;
; ;	more	sectors remain to load, check for track change
; 		INC	D
; 		LD	A,D	;sector=27?, if so, change tracks
; 		CP	27
; 		JP	C,load1	;carry generated if sector<27
; ;
; ;	end of	current track,	go to next track
; 		LD	D, 1	;begin with first sector of next track
; 		INC	C	;track=track+1
; ;
; ;	save	register state, and change tracks
; 		PUSH	BC
; 		PUSH	DE
; 		PUSH	HL
; 		CALL	settrk	;track address set from register c
; 		POP	HL
; 		POP	DE
; 		POP	BC
; 		JP	load1	;for another sector
;
;	end of	load operation, set parameters and go to cp/m
gocpm:
		LD	A, 0c3h	;c3 is a jmp instruction
		LD	(0),A	;for jmp to wboot
		LD	HL, wboote	;wboot entry point
		LD	(1),HL	;set address field for jmp at 0
;
		LD	(5),A	;for jmp to bdos
		LD	HL, bdos	;bdos entry point
		LD	(6),HL	;address field of Jump at 5 to bdos
;
		LD	BC, 80h	;default dma address is 80h
		CALL	setdma
		EI	;enable the interrupt system
		LD	A,(cdisk)	;get current disk number
		LD	C, A	;send to the ccp
		JP	ccp	;go to cp/m for further processing
;
;
;	simple i/o handlers (must be filled in by user)
;	in each case, the entry point is provided, with space reserved
;	to insert your own code
;
const:	;console status, return 0ffh if character ready, 00h if not
		LD A,0H
		RET
;
conin:	;console character into register a
		CALL KEY_SCAN_LAP
		RET
;
conout:	;console character output from register c
		LD A,C
		CALL PUTCHAR
		RET
;
list:	;list character from register c
		LD	A, C	;character to register a
		RET	;null subroutine
;
listst:	;return list status (0 if not ready, 1 if ready)
		XOR	A	;0 is always ok to return
		RET
;
punch:	;punch	character from	register C
		LD	A, C	;character to register a
		RET	;null subroutine
;
;
reader:	;reader character into register a from reader device
		LD	A, 1ah	;enter end of file for now (replace later)
		AND	7fh	;remember to strip parity bit
		RET
;
;
;	i/o drivers for the disk follow
;	for now, we will simply store the parameters away for use
;	in the read and write	subroutines
;
home:	;move to the track 00	position of current drive
;	translate this call into a settrk call with Parameter 00
		LD	A,(hstwrt)	;check for pending write
		OR	A
		JP	NZ,homed
		LD	(hstact),A	;clear host active flag
homed:
		RET	;we will move to 00 on first read/write
;
seldsk:	;select disk given by register c
		LD	HL, 0000h	;error return code
		LD	A, C ; cはドライブ番号
		LD	(sekdsk), A ; seek disk number
		CP	4	;must be between 0 and 3
		RET	NC	;no carry if 4, 5,...
;	disk number is in the proper range
		ADD  A, 4 ; 第3ビットを1にして、ドライブをイネーブルにする。
		LD  B, A ; 第3ビットを立てたdrive numberをBにコピー
		LD A, (fdc_control_command) ; 直近に発行したfdc control commandをAにコピー
		AND 0F8H ; 下位3ビットをクリア。
		OR  B ; 保存している下位3ビットと新しい上位5ビットを結合してfdc control commandを作る
		CALL FDC_CONTROL_OUT
		LD A,C ; 今後の処理のために、もう一度、ドライブ番号をAに入れる。

;		DS	10	;space for disk select
;	compute proper disk Parameter header address
;		LD	A,(diskno)
		LD	L, A	;l=disk number 0, 1, 2, 3
		LD	H, 0	;high order zero
		ADD	HL,HL	;*2
		ADD	HL,HL	;*4
		ADD	HL,HL	;*8
		ADD	HL,HL	;*16 (size of each header)
		LD	DE, dpbase ;base of parm block
		ADD	HL,DE	;hl=,dpbase (diskno*16)(curdsk)
		RET
;
settrk:
	;set track given by registers BC
		LD	H,B
		LD	L,C
		LD	(sektrk),HL	;track to seek
		RET
;
setsec:	;set sector given by register c
		LD	A, C
		LD	(seksec),A
		RET
;
;
sectran:
	;translate sector number BC
		LD	H,B
		LD	L,C
		RET

;
setdma:	;set	dma address given by registers b and c
		LD	L, C	;low order address
		LD	H, B	;high order address
		LD	(dmaadr),HL	;save the address
		RET
;
;
;*****************************************************
;*                                                   *
;*	The READ entry point takes the place of      *
;*	the previous BIOS defintion for READ.        *
;*                                                   *
;*****************************************************
read:
	;read the selected CP/M sector
		XOR	A
		LD	(unacnt),A
		LD	A,1
		LD	(readop),A	;read operation
		LD	(rsflag),A	;must read data
		LD	A,wrual
		LD	(wrtype),A	;treat as unalloc
		JP	rwoper	;to perform the read
;
;
;*****************************************************
;*                                                   *
;*	The WRITE entry point takes the place of     *
;*	the previous BIOS defintion for WRITE.       *
;*                                                   *
;*****************************************************
write:
	;write the selected CP/M sector
		XOR	A	;0 to accumulator
		LD	(readop),A	;not a read operation
		LD	A,C	;write type in c
		LD	(wrtype),A
		CP	wrual	;write unallocated?
		JP	NZ,chkuna	;check for unalloc
;
;	write to unallocated, set parameters
		LD	A,blksiz/128	;next unalloc recs
		LD	(unacnt),A
		LD	A,(sekdsk)	;disk to seek
		LD	(unadsk),A	;unadsk = sekdsk
		LD	HL,(sektrk)
		LD	(unatrk),HL	;unatrk = sectrk
		LD	A,(seksec)
		LD	(unasec),A	;unasec = seksec
;
chkuna:
	;check for write to unallocated sector
		LD	A,(unacnt)	;any unalloc remain?
		OR	A
		JP	Z,alloc	;skip if not
;
;	more unallocated records remain
		DEC	A	;unacnt = unacnt-1
		LD	(unacnt),A
		LD	A,(sekdsk)	;same disk?
		LD	HL,unadsk
		CP	(HL)	;sekdsk = unadsk?
		JP	NZ,alloc	;skip if not
;
;	disks are the same
		LD	HL,unatrk
		CALL	sektrkcmp	;sektrk = unatrk?
		JP	NZ,alloc	;skip if not
;
;	tracks are the same
		LD	A,(seksec)	;same sector?
		LD	HL,unasec
		CP	(HL)	;seksec = unasec?
		JP	NZ,alloc	;skip if not
;
;	match, move to next sector for future ref
		INC	(HL)	;unasec = unasec+1
		LD	A,(HL)	;end of track?
		CP	cpmspt	;count CP/M sectors
		JP	C,noovf	;skip if no overflow
;
;	overflow to next track
		LD	(HL),0	;unasec = 0
		LD	HL,(unatrk)
		INC	HL
		LD	(unatrk),HL	;unatrk = unatrk+1
;
noovf:
	;match found, mark as unnecessary read
		XOR	A	;0 to accumulator
		LD	(rsflag),A	;rsflag = 0
		JP	rwoper	;to perform the write
;
alloc:
	;not an unallocated record, requires pre-read
		XOR	A	;0 to accum
		LD	(unacnt),A	;unacnt = 0
		INC	A	;1 to accum
		LD	(rsflag),A	;rsflag = 1
;
;*****************************************************
;*                                                   *
;*	Common code for READ and WRITE follows           *
;*                                                   *
;*****************************************************
rwoper:
	;enter here to perform the read/write
		XOR	A	;zero to accum
		LD	(erflag),A	;no errors (yet)
		LD	A,(seksec)	;compute host sector
		OR	A	;carry = 0
		RRA	;shift right
		LD	(sekhst),A	;host sector to seek
;
;	active host sector?
		LD	HL,hstact	;host active flag
		LD	A,(HL)
		LD	(HL),1	;always becomes 1
		OR	A	;was it already?
		JP	Z,filhst	;fill host if not
;
;	host buffer active, same as seek buffer?
		LD	A,(sekdsk)
		LD	HL,hstdsk	;same disk?
		CP	(HL)	;sekdsk = hstdsk?
		JP	NZ,nomatch
;
;	same disk, same track?
		LD	HL,hsttrk
		CALL sektrkcmp	;sektrk = hsttrk?
		JP	NZ,nomatch
;
;	same disk, same track, same buffer?
		LD	A,(sekhst)
		LD	HL,hstsec	;sekhst = hstsec?
		CP	(HL)
		JP	Z,match	;skip if match
;
nomatch:
	;proper disk, but not correct sector
		LD	A,(hstwrt)	;host written?
		OR	A
		CALL	NZ,writehst	;clear host buff
;
filhst:
	;may have to fill the host buffer
		LD	A,(sekdsk)
		LD	(hstdsk),A
		LD	HL,(sektrk)
		LD	(hsttrk),HL
		LD	A,(sekhst)
		LD	(hstsec),A
		LD	A,(rsflag)	;need to read?
		OR	A
		CALL NZ,readhst	;yes, if 1
		XOR	A	;0 to accum
		LD	(hstwrt),A	;no pending write
;
match:
	;copy data to or from buffer
		LD	A,(seksec)	;mask buffer number
		AND	secmsk	;least signif bits
		LD	L,A	;ready to shift
		LD	H,0	;double count
		ADD	HL,HL
		ADD	HL,HL
		ADD	HL,HL
		ADD	HL,HL
		ADD	HL,HL
		ADD	HL,HL
		ADD	HL,HL
;	hl has relative host buffer address
		LD	DE,hstbuf
		ADD	HL,DE	;hl = host address
		EX	DE,HL	;now in DE
		LD	HL,(dmaadr)	;get/put CP/M data
;		LD	C,128	;length of move
		LD	C,80H	;length of move
		LD	A,(readop)	;which way?
		OR	A
		JP	NZ,rwmove	;skip if read
;
;	write operation, mark and switch direction
		LD	A,1
		LD	(hstwrt),A	;hstwrt = 1
		EX	DE,HL	;source/dest swap
;
rwmove:
	;C initially 128(80H), DE is source, HL is dest
		LD	A,(DE)	;source character
		INC	DE
		LD	(HL),A	;to dest
		INC	HL
		DEC	C	;loop 128 times
		JP	NZ,rwmove
;
;	data has been moved to/from host buffer
		LD	A,(wrtype)	;write type
		CP	wrdir	;to directory?
		LD	A,(erflag)	;in case of errors
		RET	NZ	;no further processing
;
;	clear host buffer for directory write
		OR	A	;errors?
		RET	NZ	;skip if so
		XOR	A	;0 to accum
		LD	(hstwrt),A	;buffer written
		CALL	writehst
		LD	A,(erflag)
		RET
;
;
;*****************************************************
;*                                                   *
;*	Utility subroutine for 16-bit compare        *
;*                                                   *
;*****************************************************
sektrkcmp:
	;HL = .unatrk or .hsttrk, compare with sektrk
		EX	DE,HL
		LD	HL,sektrk
		LD	A,(DE)	;low byte compare
		CP	(HL)	;same?
		RET	NZ	;return if not
;	low bytes equal, test high 1s
		INC	DE
		INC	HL
		LD	A,(DE)
		CP	(HL)	;sets flags
		RET
;
;
;*****************************************************
;*                                                   *
;*	WRITEHST performs the physical write to      *
;*	the host disk, READHST reads the physical    *
;*	disk.					     *
;*                                                   *
;*****************************************************
writehst:
	;hstdsk = host disk #, hsttrk = host track #,
	;hstsec = host sect #. write "hstsiz" bytes
	;from hstbuf and return error flag in erflag.
	;return erflag non-zero if error
		LD A,(hsttrk)
		SRL A
		JR C,SET_WRT_SIDE1
SET_WRT_SIDE0: ; TRACK NO. IS EVEN --> SIDE 0
  		LD D,4H
		JR WRT_CONTINUE
SET_WRT_SIDE1: ; TRACK NO. IS ODD --> SIDE 1
		LD D,24H
WRT_CONTINUE:
		ADD A,01H
		LD E,A ; E is Track No.
		CALL SEEK
		LD A,(hstsec)
		ADD A,01H
		LD C,A ; C is Sector No.
		BIT 5,D ; BIT IS 1 THEN SIDE 1. IS 0 THEN SIDE 0.
		JR NZ,WRITE_SIDE1
WRITE_SIDE0:
		CALL GO_DMA_AND_WRITE0
		JR WRITE_END
WRITE_SIDE1:
		CALL GO_DMA_AND_WRITE1
WRITE_END:
		LD A,0 ; allways SUCCESS
		LD (erflag),A
		RET
;
readhst:
	;hstdsk = host disk #, hsttrk = host track #,
	;hstsec = host sect #. read "hstsiz" bytes
	;into hstbuf and return error flag in erflag.
		LD A,(hsttrk)
		SRL A
		JR C,SET_RD_SIDE1
SET_RD_SIDE0: ; TRACK NO. IS EVEN ---> SIDE 0
		LD D,4H
		JR READ_CONTINUE
SET_RD_SIDE1: ; TRACK NO. IS ODD ---> SIDE 1
		LD D,24H
READ_CONTINUE:
		ADD A,01H
		LD E,A ; E is Track No.
		CALL SEEK
		LD A,(hstsec)
		ADD A,01H
		LD C,A ; C is Sector No.
		BIT 5,D ; BIT IS 1 THEN SIDE 1. IS 0 THEN SIDE 0.
		JR NZ,READ_SIDE1
READ_SIDE0:
		CALL GO_DMA_AND_READ0
		JR READ_END
READ_SIDE1:
		CALL GO_DMA_AND_READ1
READ_END:
		LD A,0 ; allways SUCCESS
		LD (erflag),A
		RET
;
; FDC COMMAND OUT subroutine
;
FDCOUT:
	OUT (FDC_COMMAND_REG),A
	LD A,30H
WLOOP: DEC A
	JR NZ,WLOOP
LOOP2:
	IN A,(FDC_STATUS_REG)
	BIT 0,A ; BUSY IS CLEAR?
	JR NZ,LOOP2
	RET
;
; RESTORE subroutine
;
RESTORE:
RESTORE_LOOP:
	LD A,44H ;  \DDENS is HIGH. Single density mode. 
	CALL FDC_CONTROL_OUT

	LD A,0CH ; restore command
	CALL FDCOUT
	BIT 7,A ; Not Ready?
	JR NZ,RESTORE_LOOP
	AND 98H
	JR NZ,RESTORE
	RET
;
; SEEK subroutine
; D is fdccontrol COMMAND
; if D=0x44 : \DDEN is HIGH. Single density mode. 
; if D=0x4  : \DDEN is LOW. Double density mode. 
; if D=0x24 : Side 1 and Double density mode.
; E is Track No.
;
SEEK:
	LD A,D ; D is control command.
	CALL FDC_CONTROL_OUT

	LD A,E
	OUT (FDC_DATA_REG),A
	LD A,1CH ; SEEK COMMAND
	CALL FDCOUT
	AND 98H
	RET
;
; DMA setting & Go
; HL is Address of DMA Command chain
;		but top value is No of DMA Command chain
DMA_ON:
	PUSH HL
	PUSH BC
	LD B,(HL)
	INC HL
	LD C,DMA_ADDRESS
	OTIR
	POP BC
	POP HL
	RET
;
; DMA setting & FDD read FOR SIDE 0
; C is Sector No.
; D is Control word.
; if D=0x44 : \DDEN is HIGH. Low density mode. 
; if D=0x4  : \DDEN is LOW. High density mode. 
; if D=0x24 : Side 1 and High density mode.
;
GO_DMA_AND_READ0:
	LD A,C
	OUT (FDC_SECTOR_REG),A
	LD A,D ; D is control command
	CALL FDC_CONTROL_OUT

	LD HL,DMA_COMMANDS
	CALL DMA_ON
	AND 20H
	LD A,82H ; READ DATA COMMAND for Side 0
DO_FDC0:
	CALL FDCOUT
	AND 0FCH
	RET
;
; DMA setting & FDD read FOR SIDE 1
; C is Sector No.
; D is Control word.
;
GO_DMA_AND_READ1:
	LD A,C
	OUT (FDC_SECTOR_REG),A
	LD A,D ; D is control command
	CALL FDC_CONTROL_OUT

	LD HL,DMA_COMMANDS
	CALL DMA_ON
	AND 20H
	LD A,8AH ; READ DATA COMMAND for Side 1
DO_FDC1:
	CALL FDCOUT
	AND 0FCH
	RET
;
; DMA setting & FDD write FOR SIDE 0
; C is Sector No.
; D is Control word.
; if D=0x44 : \DDEN is HIGH. Low density mode. 
; if D=0x4  : \DDEN is LOW. High density mode. 
; if D=0x24 : Side 1 and High density mode.
;
GO_DMA_AND_WRITE0:
	LD A,C
	OUT (FDC_SECTOR_REG),A
	LD A,D ; D is control command
	CALL FDC_CONTROL_OUT

	LD HL,DMA_WRITE_COMMANDS
	CALL DMA_ON
	AND 20H
	LD A,0A2H ; WRITE DATA COMMAND for Side 0
DO_FDC_WR0:
	CALL FDCOUT
	AND 0FCH
	RET
;
; DMA setting & FDD write FOR SIDE 1
; C is Sector No.
; D is Control word.
;
GO_DMA_AND_WRITE1:
	LD A,C
	OUT (FDC_SECTOR_REG),A
	LD A,D ; D is Control command
	CALL FDC_CONTROL_OUT

	LD HL,DMA_WRITE_COMMANDS
	CALL DMA_ON
	AND 20H
	LD A,0AAH ; WRITE DATA COMMAND for Side 1
DO_FDC_WR1:
	CALL FDCOUT
	AND 0FCH
	RET

;
; DMA setting & FDD read FOR WBOOT at SIDE 0
; C is Sector No.
;
GO_DMA_AND_READ_WBOOT0:
	LD A,C
	OUT (FDC_SECTOR_REG),A
	LD HL,DMA_WBOOT_COMMANDS
	CALL DMA_ON
	LD A,82H ; READ DATA COMMAND for Side 0
;	LD A,8AH ; READ DATA COMMAND for Side 1
	CALL FDCOUT
	AND 0FCH
	RET
;
; DMA setting & FDD read FOR WBOOT at SIDE 1
; C is Sector No.
;
GO_DMA_AND_READ_WBOOT1:
	LD A,C
	OUT (FDC_SECTOR_REG),A
	LD HL,DMA_WBOOT_COMMANDS
	CALL DMA_ON
	; LD A,82H ; READ DATA COMMAND for Side 0
	LD A,8AH ; READ DATA COMMAND for Side 1
	CALL FDCOUT
	AND 0FCH
	RET

;;
; FDC CONTROL_COMMAND OUT subroutine
;
FDC_CONTROL_OUT:
	OUT (FDC_CONTROL_REG),A ; 
	LD (fdc_control_command),A ; save fdc control command.
	RET


;
; Sireal I/O subroutines
;
SIO_INIT:
	;; Initialize SIO
	IN	A,(SIOAC)
	;; Reset both Ch.
	LD	A,18H
	OUT	(SIOAC),A

	;; Ch.A WR1
	LD	A,01H
	OUT	(SIOAC),A
	XOR	A
	OUT	(SIOAC),A

	;; Ch.A WR4
	LD	A,04H
	OUT	(SIOAC),A
	LD	A,44H		; x16 1 N
	OUT	(SIOAC),A

	;; Ch.A WR3
	LD	A,03H
	OUT	(SIOAC),A
	LD	A,0C1H		; 8bit Receiver enable
	OUT	(SIOAC),A
	
	;; Ch.A WR5
	LD	A,05H
	OUT	(SIOAC),A
	LD	A,0EAH		; 8bit Transmitter enable
	OUT	(SIOAC),A
	RET

STROUT:
	LD	A,(HL)
	AND	A
	RET	Z
	LD C,A
	CALL	CONOUT
	INC	HL
	JR	STROUT

;
; DMA COMMAND CHAIN
;
DMA_COMMANDS:
	DB 15H
	DB 0C3H,0C3H,0C3H,0C3H,0C3H,0C3H
	DB 0BBH,01H,0BFH
	DB 6DH
	DB 0CBH,0FFH,00H,02CH,010H,08DH
	; DB 029H,0FBH ; host buffer address
	DB hstbuf.@L ; host buffer address 
	DB hstbuf.@H ; host buffer address
	DB 9AH
	DB 0CFH,87H
DMA_WRITE_COMMANDS:
	DB 16H
	DB 0C3H,0C3H,0C3H,0C3H,0C3H,0C3H
	DB 83H
	DB 79H
	; DB 029H,0FBH ; host buffer address
	DB hstbuf.@L ; host buffer address
	DB hstbuf.@H ; host buffer address
	DB 00H,0FFH ; byte number of transfer
	DB 14H,28H,8DH
	DB 0CBH,00H ; FDC data register
	DB 9AH
	DB 0CFH,05H
	DB 0CFH,87H

;
; DMA WBOOT COMMAND CHAIN
;
DMA_WBOOT_COMMANDS:
	DB 15H,0C3H,0C3H,0C3H,0C3H,0C3H,0C3H
	DB 0BBH,01H,0BFH
	DB 6DH
	DB 0CBH,0FFH,00H,02CH,010H,08DH
	DB 00H
wboot_add:	DB 0DCH ; DC00H is 62K MEMORY MODEL
	DB 9AH
	DB 0CFH,87H

;
OPENMSG:
	DB CR,LF,"SORD M68(Z80 MODE) CP/M-80 V2.2 62K SYSTEM",CR,LF,00H
;COPYMSG:
;	DB "Copyright 1979 (C) by Digital Research.",CR,LF,00H
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; キーボード初期化ルーチン
;
KBD_INIT:
;
; キーボードスキャンバッファーを0で埋める。必要ないかも。
;
	LD HL,KEYBOARD_SCAN_BUFFER
	LD BC,10H
	LD A,0H
	LD (HL),A
	LD D,H
	LD E,L
	INC DE
	DEC BC
	LD A,B
	OR C
	RET Z
	LDIR
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CRT 初期化ルーチン
;

CRT_INIT:

	LD HL,0F000H ; VRAMの左上のアトリビュートアドレス
	LD BC,0800H

; カーソル座標を00Hに設定する。
; 注：画面左上がカーソル座標では0000Hになる。VRAMにおけるテキスト画面左上(F800H)ではないことに注意。
	LD A,0EH ; R14 (cursor H)
	OUT (CRTC_ADD),A
	LD A,0H
	OUT (CRTC_VAL),A
	LD A,0FH ; R15 (cursor L)
	OUT (CRTC_ADD),A
	LD A,00H
	OUT (CRTC_VAL),A

; カーソルの形状と点滅の設定
	LD A,0AH ; R10 (cursol start address)
	OUT (CRTC_ADD),A
;	LD A,C0H ; 点滅、豆腐カーソル
	LD A,C7H ; 点滅、アンスコカーソル
;	LD A,0H ; 表示せず。
	OUT (CRTC_VAL),A
	LD A,0BH ; R11 (cursol end address)
	OUT (CRTC_ADD),A
	LD A,0AH
;	LD A,0H ; 表示せず。
	OUT (CRTC_VAL),A

;
; 	一度画面全てを消す(スペースで埋める)。
;
	LD B,050H
	LD DE,0FFFFH
	LD A,20H ; 20Hはアスキーコードでスペース
CLEAR_ALL_LINE:
	OUT (0D2H),A ; D2Hポートになにか書くと次の命令は別のページ(この場合はVRAMのページ)に行う。
	LD (HL),A ; F000H～FFFFHまで20Hで埋めている。アトリビュートに20H書いても問題ないみたい。
	INC HL
	SBC HL,DE
	JR NZ,CLEAR_ALL_LINE

	LD DE, VRAM_TXT_TOP ; 最初の文字列表示位置(左上隅)
	LD (CURSOR_LOCATE),DE
	LD (TOP_VIEW),DE
	LD DE, 0FFD0H
	LD (NEED_DO_SCROLL_POINT),DE

	RET ; 初期化処理終了


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CRTCコントロールサブルーチン群
;

;
; VRAM_TXT_TOP : VRAMテキストエリアの先頭(F800H)
; CURSOR_LOCATE : 現在のカーソル位置
; CR_NOW_CURSOL_LOCATE : CRコードが入った時のカーソル位置
; TOP_VIEW : 画面左上端のアドレス(スクロールによって動的に変化する)
; CR_BASE_ADDRESS : CR後のカーソル位置
; CR_NEW_ORIGIN : FFFFHの境界を越え、更に画面右端を超えた時にCRアドレス計算の原点になるアドレス

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; １文字表示サブルーチン
; A regに表示するアスキーコードが入っている。
;

PUTCHAR:
	AND A
	JR Z, PUTCHAR_RET
	LD DE,(CURSOR_LOCATE)
	CP CR
	JP Z, DO_CR ; CRの処理
	CP LF
	JP Z, DO_LF ; LFの処理
	CP BS
	JP Z, DO_BS ; BSの処理
DO_NORMAL:
	OUT (0D2H),A ; access to RAM page 1
	LD (DE),A ; put character
;
; 越境判定。FFFFHの次はF800Hになる
;
	PUSH AF
	LD A,D
	CP 0FFH
	JR NZ,CURSOR_BOUNDARY_END
	LD A,E
	CP 0FFH
	JR NZ,CURSOR_BOUNDARY_END
	LD DE, VRAM_TXT_TOP-1 ; 現在のカーソル位置 = F800H - 1 
CURSOR_BOUNDARY_END:
	POP AF
	INC DE
DO_CR_LF_BS_RETURN: ; CR,LF,BSの処理で戻ってくる
	PUSH HL
	PUSH AF
	PUSH DE
	CALL DO_SCROLL ; 1行スクロール処理
	POP DE
	POP AF
	POP HL
	LD (CURSOR_LOCATE),DE ; 現在のカーソル位置を更新。
;
; カーソルをCURSOL_LOCATE=DEの位置に表示する(HD46505Sの機能)
;
	PUSH AF
	PUSH DE
	PUSH HL
	EX DE,HL
	LD A,0EH ; R14 (cursor H)
	OUT (CRTC_ADD),A
	LD A,H
	OUT (CRTC_VAL),A
	LD A,0FH ; R15 (cursor L)
	OUT (CRTC_ADD),A
	LD A,L
	OUT (CRTC_VAL),A
	POP HL
	POP DE
	POP AF
;
PUTCHAR_RET:
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; CR処理ルーチン(スクロール処理対応版)
;

DO_CR:
	PUSH HL
	PUSH BC
	XOR A ; A=0にする
	LD (CR_NOW_CURSOL_LOCATE),DE ; 現在のカーソル位置保存
	LD HL,(TOP_VIEW) ; 左上端をロード
	EX DE,HL
	SBC HL,DE ; 左上端アドレス - 現在のカーソル位置
	JR NC,CONTINUE_CR ; オーバーフローしていないなら単純処理
;
;   TOP_VIEWがCR_NOW_CURSOL_LOCATEよりも大きいとき。
;	この状況は、スクロールされた時に発生する。
;	つまり、殆どの場合、この処理が実行される。
;
	LD HL,(TOP_VIEW)
	LD DE,(CR_NOW_CURSOL_LOCATE) ; CRコードが入った時のカーソル位置
	LD BC,WIDTH_SCREEN ;  50H =  画面の桁数(80d)
	LD (CR_BASE_ADDRESS),HL ; 初期値は左上端アドレス
CR_SCAN_0:
	LD HL,(CR_BASE_ADDRESS)
	LD (CR_BASE_ADDRESS_PRE),HL
	ADD HL,BC ; 50H(80d)づつ足していく
	LD (CR_BASE_ADDRESS),HL
	JP NC,CR_SCAN_0 	; 越境をチェックしていて、オーバーフローまでループする。
						; オーバーフローしたらジャンプ
	LD HL,(CR_BASE_ADDRESS_PRE) ; ループを抜けたときHLはオーバーフロー後の値になっていいる。
								; 足し算前の値に戻す
	; FFFFHを超えた値がいくつかを調べる。
	; FFFFHまでの値と合わせて、それが1行の桁数50H(80d)を
	; 超えたなら、CR後の現在カーソル位置は
	; その新しい行の先頭アドレスにならなくてはならない。
	; 
	LD DE,0FFFFH ; 境界値
	EX DE,HL
	SBC HL,DE ; FFFFH - CR_BASE_ADDRESS_PRE = A
			  ; オーバーフローする一つ前の値でFFFFHを引く
	LD DE,WIDTH_SCREEN ; 50H(80d)
	EX DE,HL
	SBC HL,DE ; 50H(80d) - A = X ; Xは境界を越えた数
	LD DE,VRAM_TXT_TOP ; VRAM_TXT_TOP = F800H
	ADD HL,DE ; F800H + X ; この値が境界を含む行の右端のアドレス
	DEC HL ; -2する
	DEC HL
	LD (CR_NEW_ORIGIN),HL ; 新しいCR評価位置になる
	LD (CR_BASE_ADDRESS),HL
	LD DE,(CR_NOW_CURSOL_LOCATE) ; CR命令を受けた時のカーソル位置

	;
	; 例えば現在カーソル位置がF819Hで新しいCR評価位置がF820Hのときに、
	; CR_2_NEW_SCAN_0のループを通ると+50Hされてしまうので、バイパスする処理。
	SBC HL,DE
	JP P,CR_BOUNDARY_RETURN ; 正であれば、ジャンプ
	;
	;
	LD HL,(CR_NEW_ORIGIN) ; 負であれば、そのまま処理を進める。
	LD BC,WIDTH_SCREEN ;  50H(80d)
CR_NEW_SCAN_0:
	LD HL,(CR_BASE_ADDRESS)
	LD (CR_BASE_ADDRESS_PRE),HL ; HL=CR_NEW_ORIGIN
	ADD HL,BC ; CR_NEW_ORIGIN + 50H +...
	LD (CR_BASE_ADDRESS),HL
	SBC HL,DE ; (CR_NEW_ORIGIN + 50H +...) > CR_NOW_CURSOL_LOCATE ?
	JP M, CR_NEW_SCAN_0 ; DEの方が大きければループ
	JP Z, CR_NEW_SCAN_0 ; 完全に一致したときも1回ループを回す
	LD HL,(CR_BASE_ADDRESS_PRE) ; HL>DE。50Hを足す一つ前の値をHLに入れる。
	LD (CR_BASE_ADDRESS),HL
	LD DE,(CR_BASE_ADDRESS) ; CR後のアドレスをDEに入れる。
	JR CR_END
;
;	TOP_VIEWがCR_NOW_CURSOL_LOCATEよりも小さいとき
;
CONTINUE_CR:
	LD HL,(TOP_VIEW)
	LD DE,(CR_NOW_CURSOL_LOCATE)
	LD BC,WIDTH_SCREEN ; 50H(80d) 
	LD (CR_BASE_ADDRESS),HL
CR_SCAN_1:
	LD HL,(CR_BASE_ADDRESS)
	LD (CR_BASE_ADDRESS_PRE),HL
	ADD HL,BC
	LD (CR_BASE_ADDRESS),HL
	SBC HL,DE	; HLが現在のカーソル位置を超えるかチェック
	JP M,CR_SCAN_1
	JP Z,CR_SCAN_1 ; 完全に一致したときも1回ループを回す。
	LD HL,(CR_BASE_ADDRESS_PRE)
	LD (CR_BASE_ADDRESS),HL
	LD DE,(CR_BASE_ADDRESS)
CR_END:
	POP BC
	POP HL
	JP DO_CR_LF_BS_RETURN; CR,LF,BSの処理の終了

CR_BOUNDARY_RETURN:
	LD DE,(CR_BASE_ADDRESS_PRE)
	JR CR_END

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; LINE_FEED 処理(スクロール処理対応版)
;

DO_LF:
	PUSH HL
	PUSH BC
	EX DE,HL ; HL <-> DE DE=現在のカーソル位置
	LD BC,WIDTH_SCREEN ; 50H(80d)
	ADD HL,BC ; HL = DE + 50H
	JR NC,CONTINUE_LF
;
;	BEYOND FFFFH BOUNDARY
;
	LD HL,(CURSOR_LOCATE)
	LD DE,0FFFFH
	EX DE,HL
	SBC HL,DE ; FFFFH - CURSOR_LOCATE = A
	LD DE,50H
	EX DE,HL
	SBC HL,DE ; 50H - A = X
;
	DEC HL ; この引き算二回の処理がないと正しい左端のアドレスが出ない。
	DEC HL ; これはCP/Mでは常にプロンプト(a>)の2文字が出ているため。
;
	LD DE,VRAM_TXT_TOP
	ADD HL,DE
CONTINUE_LF:
	EX DE,HL ; DE <-> HL
	POP BC
	POP HL
	JP DO_CR_LF_BS_RETURN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; BACK SPACE 処理
;
DO_BS:
	LD A, 20H ; 20H -> Space ASCII CODE
	DEC DE
	OUT (0D2H),A ; access to RAM page 1
	LD (DE),A ; 20H(スペース)を表示させる。
	JP DO_CR_LF_BS_RETURN ; BSの為の復帰点に戻る。

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; スクロール処理
; SORD M23のCRTCであるHD4650SPはスクロール機能がある。
; 具体的には表示したい画面左上端のアドレスを、R12、R13に上位、下位アドレスとして入れることで実行される。
; SORD M23のVRAMのテキストエリアはF800H～FFFFHであるが、画面に表示される文字は80桁×25行の2000(7D0H)文字である。
; よって、余りが生じるため、スクロール処理は殆どがこの余りの処理に費やされる。
;

DO_SCROLL:
	LD (CURSOR_LOCATE),DE ; 現在のカーソル位置を更新
	LD HL,(TOP_VIEW) ; 左上端アドレス
	LD DE,7D0H ; 全画面文字数
	ADD HL,DE ; TOP_VIEW + 7D0H ; 
	JR C,SCROLL_POINT_BEYOND_FFFF ; 境界値をまたいでいる、オーバーフローしたらジャンプ
	JR SCROLL_POINT ; スクロールすべきカーソル位置の更新へ
SCROLL_POINT_BEYOND_FFFF:
	LD HL,(TOP_VIEW)
	LD DE,0FFFFH
	EX DE,HL
	SBC HL,DE ; FFFFH - TOP_VIEW = A
	LD DE,7CEH ; 7D0H - 2H
	EX DE,HL
	SBC HL,DE ; 7CEH - A
	LD DE,VRAM_TXT_TOP
	ADD HL,DE
	;
SCROLL_POINT:
	; update need_do_scroll_point
	LD (NEED_DO_SCROLL_POINT),HL
	LD DE,(CURSOR_LOCATE)
	LD A,D ; need_do_scroll_point == CURSOL_LOCATE?
	CP H
	RET NZ
	LD A,E
	CP L
	RET NZ
;
; TOP_VIEWの更新
;

; スクロールから外れた行をスペースで埋める。
	LD HL,(TOP_VIEW) ; スクロール直前の左上端アドレス
	PUSH BC
	PUSH DE
	PUSH AF
	LD B,04FH ; 4FH=79
	LD DE,0FFFFH
	LD A,20H ; 20H is Space
CLEAR_1_LINE:
	OUT (0D2H),A
	LD (HL),A ; スペースで埋める
	PUSH HL ; HL < FFFFHのとき、下の引き算はオーバーフローするが、
			; HL=F800Hの時に実行すると、HL=F801となり、
			; その後INC HLでF802Hになるため、スペースによる穴埋めがF801Hのみ実行されないことになる。
			; なので、一度、HLを退避して、引き算してFFFFHでないか判定したのち、POPして戻している。
			; このコードは遅いが、現状、これを採用する。20221229
	SBC HL,DE ; HL - FFFFH = HL
	POP HL
	JR Z, CLEAR_BEYOND_BOUNDARY ; HL = FFFFHのときは境界を越えた
	INC HL
	DJNZ CLEAR_1_LINE
	JR CLEAR_1_LINE_END
	; 越境時の処理
CLEAR_BEYOND_BOUNDARY:
	LD HL,VRAM_TXT_TOP ; HLをVRAMの先頭(F800H)にセット
CLEAR_1_LINE_BOUNDARY: ; B回ループする
	OUT (0D2H),A
	LD (HL),A
	INC HL
	DJNZ CLEAR_1_LINE_BOUNDARY
CLEAR_1_LINE_END:
	POP AF
	POP DE
	POP BC
;
;
	LD HL,(TOP_VIEW)
	LD DE,50H
	ADD HL,DE
	JR NC,UPDATE_TOP_VIEW
;
;	BEYOND FFFFH BOUNDARY
;
	LD DE,0FFFFH
	LD HL,(TOP_VIEW)
	EX DE,HL
	SBC HL,DE ; FFFFH - TOP_VIEW = A
	LD DE,50H
	EX DE,HL
	SBC HL,DE ; 50H - A = X
	LD DE,0F800H
	ADD HL,DE ; F800H + X = TOP_VIEW
;
	DEC HL ; この引き算二回の処理がないと正しい左端のアドレスが出ない。
	DEC HL ; これはCP/Mでは常にプロンプト(a>)の2文字が出ているため。
;
UPDATE_TOP_VIEW:
	LD (TOP_VIEW),HL
	;
	; 1行スクロール
	;
	PUSH AF
	LD A,0CH ; START ADDRESS HIGH
	OUT (CRTC_ADD),A
	LD A,H ; スクロールしたときに左隅になるVRAMの上位アドレス
	OUT (CRTC_VAL),A
	LD A,0DH ; START ADDRESS LOW
	OUT (CRTC_ADD),A
	LD A,L ; スクロールしたときに左隅になるVRAMの下位アドレス
	OUT (CRTC_VAL),A
	POP AF
SCROLL_END:
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; キースキャン サブルーチン
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

KEY_SCAN_LAP:
	PUSH HL
	PUSH BC
KEY_SCAN_LAP_LOOP:
	LD HL,PORT_INDEX
	LD BC,0FDFH
	CALL KEY_SCAN
	AND A
	JR Z,KEY_SCAN_LAP_LOOP
	POP BC
	POP HL
	RET

KEY_SCAN:
	INC C
	INI ; INIでキーボードポートE0~EFをスキャンする。
	JR NZ,KEY_SCAN ; Cをインクリメントしていくと、1->2->3...e->f->0となって、スキャン終了となる。
	LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
	LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
SCAN_LOOP:
	INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
	IN A,(C)
	AND (HL) ; INIでスキャンした結果と照合。
	LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
	INC HL ; メモリアドレスをインクリメント。
	DJNZ SCAN_LOOP ; 16回繰り返す

	LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
	LD D,0H ; インデックスを0にする。
	JR KEY_LOOP_1
SCAN_LOOP_RETURN:
	RET

KEY_LOOP_1:
	LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
	AND A ; 0でないか、つまり、空の値でないかチェック。
	JR NZ, KEY_LOOP_2 ; 空でない場合、つまり、何かが押されているならジャンプ
	INC D ; インデックスをインクリメント
	INC HL ; ポインタをインクリメント
	LD A,D
	CP 0FH ; 16バイトチェックしたか？
	LD A,0H ; なにもキーが押されなかったときはAレジスタを0にする。
	JR Z,SCAN_LOOP_RETURN ; 終了
	JR KEY_LOOP_1 

;
; 何かが押されている時に実行される。
;

KEY_LOOP_2: 
	CP 04H ; キーボード1段目のキーが押された。(1,2,3,4,5,6,7,8,9,0,-,=,BS)
	JP NZ,CHECK_ROW2
	LD D,0
	JP PROCESS_KEY
CHECK_ROW2:
	CP 08H ; キーボード2段目のキーが押された。(q,w,e,r,t,y,u,i,o,p,CR)
	JP NZ,CHECK_ROW3
	LD D,1
	JP PROCESS_KEY
CHECK_ROW3:
	CP 10H ; キーボード3段目のキーが押された。(control,a,s,d,f,g,h,j,k,l)
	JP NZ,CHECK_ROW4
	LD A,L
	AND 0FH
	CP 00H
	JP Z,CODE_CONTROL  ; コントロールキー特殊処理
	LD D,2
	JP PROCESS_KEY
CHECK_ROW4:
	CP 20H ; キーボード4段目のキーが押された。(shift,z,x,c,v,b,n,m,shift)
	JP NZ,CHECK_ROW5
	LD A,L
	AND 0FH
	CP 00H
	JP Z,CODE_SHIFT   ; シフトキー特殊処理
	LD D,3
	JP PROCESS_KEY
CHECK_ROW5:
	JP Z,KEY_LOOP_END  ; 元の CODE_40 ラベルへのジャンプを KEY_LOOP_END に変更	CP 40H

;
; 共通のキーマップ参照ルーチン
; 入力: D = キーボード段数（0-3）
;       L = キー位置
; 出力: A = マップされたキーコード
;
GET_KEYMAP:
	PUSH HL
	PUSH BC
	LD A,L
	AND 0FH        ; 下位4ビットのみ使用
	LD B,A         ; キー位置
	LD A,D         ; キーボード段数
	ADD A,A        ; ×16のために4回シフト
	ADD A,A
	ADD A,A
	ADD A,A
	ADD A,B        ; キー位置を加算
	LD HL,KEY_MAP
	LD B,0
	LD C,A
	ADD HL,BC      ; HL = KEY_MAP + オフセット
	LD A,(HL)      ; マップされたコードを取得
	POP BC
	POP HL
	RET

;
; 共通のキー処理ルーチン
; 入力: D = キーボード段数（0-3）
;
PROCESS_KEY:
	CALL GET_KEYMAP
	PUSH AF
	CALL KEY_BREAK_WAIT
	POP AF
	JP SCAN_LOOP_RETURN

;
; 特殊キー(CONTROL,SHIFT)の処理
;

CODE_CONTROL:
	CALL CONTROL_KEY_NEXT_GET
	JP SCAN_LOOP_RETURN

CODE_SHIFT:
	CALL SHIFT_KEY_NEXT_GET
	JP SCAN_LOOP_RETURN

KEY_LOOP_END:
	LD A, 1BH ; どれにも該当しないキーを押したときは、エスケープキーを押したことにする。
	JP SCAN_LOOP_RETURN

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; キーの押下が解放されるまで待つサブルーチン
;

KEY_BREAK_WAIT:
	LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
	LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
BREAK_SCAN_LOOP:
	INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
	IN A,(C)
	AND (HL) ; INIでスキャンした結果と照合。
	LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
	INC HL ; メモリアドレスをインクリメント。
	DJNZ BREAK_SCAN_LOOP ; 16回繰り返す

	LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
	LD D,0H ; インデックスを0にする。
	LD B,0FH
	LD E,0H

BREAK_KEY_LOOP:
	LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
	ADD A, E 
	LD E, A ; Eにキースキャンの値を積算する。
	INC D ; インデックスをインクリメント
	INC HL ; ポインタをインクリメント
	DJNZ BREAK_KEY_LOOP
	LD A,E ; キースキャンの値の総和をAに戻す。
	AND A ; ゼロかどうか判定の為、自分自身でANDをとる。
	RET Z ; 全てのキーボードポートが0の時にリターンする。
	JR KEY_BREAK_WAIT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; SHIFTキーと同時に押されたキーをゲットするサブルーチン
;

SHIFT_KEY_NEXT_GET:
	LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
	LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
SHIFT_SCAN_LOOP:
	INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
	IN A,(C)
	LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
	INC HL ; メモリアドレスをインクリメント。
	DJNZ SHIFT_SCAN_LOOP ; 16回繰り返す

	LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
	LD D,0H ; インデックスを 1 にする。
	LD B,0FH ; B=FH=16
	LD E,0H

;
; SHIFTキーを離すか、他のキーが押されるまではループする。
;

SHIFT_NEXT_KEY_LOOP:
	LD A, (PORT_INDEX)
	AND A
	LD A,1BH
	RET Z ; [EE00]=0、SHIFTキー押されてないならリターンする。
	INC HL
	INC D
	LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
	AND A
	JR NZ, SHIFT_KEY_LOOP ; キーが押下されている時はジャンプする。
	LD A,D
	CP 0FH ; D=A=16バイトチェックしたか？
	JR Z, SHIFT_KEY_NEXT_GET ; 16バイト読み込んで、SHIFTキー以外何も押されていないなら、一番最初のループに戻る
	JR SHIFT_NEXT_KEY_LOOP ; 16バイト読んでないなら、次のメモリを読む。
	
SHIFT_KEY_LOOP:
	CP 04H
	JP Z, CODE_04_SHIFT
	CP 08H
	JP Z, CODE_08_SHIFT
	CP 10H
	JP Z, CODE_10_SHIFT
	CP 20H
	JP Z, CODE_20_SHIFT


CODE_04_SHIFT:
	LD A,L
	AND 0FH

	CP 01H
	JP Z, CODE_1_SHIFT
	CP 02H
	JP Z, CODE_2_SHIFT
	CP 03H
	JP Z, CODE_3_SHIFT
	CP 04H
	JP Z, CODE_4_SHIFT
	CP 05H
	JP Z, CODE_5_SHIFT
	CP 06H
	JP Z, CODE_6_SHIFT
	CP 07H
	JP Z, CODE_7_SHIFT
	CP 08H
	JP Z, CODE_8_SHIFT
	CP 09H
	JP Z, CODE_9_SHIFT

CODE_08_SHIFT:
	LD A,L
	AND 0FH

	CP 0BH
	JP Z, CODE_AT_MARK_SHIFT
	CP 0CH
	JP Z, CODE_L_SQ_PAR_SHIFT

CODE_10_SHIFT:
	LD A,L
	AND 0FH

	CP 0AH
	JP Z, CODE_SEMI_COLON_SHIFT
	CP 0BH
	JP Z, CODE_COLON_SHIFT
	CP 0CH
	JP Z, CODE_R_SQ_PAR_SHIFT

CODE_20_SHIFT:

	LD A,L
	AND 0FH

	CP 09H
	JP Z, CODE_COMMA_SHIFT
	CP 0AH
	JP Z, CODE_PERIOD_SHIFT
	CP 0BH
	JP Z, CODE_SLASH_SHIFT

	LD A,0H
	RET

CODE_1_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '!'
	RET
CODE_2_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, 22H
	RET
CODE_3_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '#'
	RET
CODE_4_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '$'
	RET
CODE_5_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '%'
	RET
CODE_6_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '&'
	RET
CODE_7_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, 27H ; 27Hは "'" 。シングルクォーテーション。
	RET
CODE_8_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '('
	RET
CODE_9_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, ')'
	RET

CODE_AT_MARK_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '`'
	RET
CODE_L_SQ_PAR_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '{'
	RET
CODE_SEMI_COLON_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '+'
	RET
CODE_COLON_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '*'
	RET
CODE_R_SQ_PAR_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '}'
	RET
CODE_COMMA_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '<'
	RET
CODE_PERIOD_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '>'
	RET
CODE_SLASH_SHIFT:
	CALL KEY_BREAK_WAIT
	LD A, '?'
	RET


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Controlキーと同時に押されたキーをゲットするサブルーチン
;

CONTROL_KEY_NEXT_GET:
	LD HL,PORT_INDEX ; キーボードポートの値が入っているメモリアドレスPORT_INDEX~PORT_INDEX+0xFHのポインタを先頭に戻している。
	LD BC,0FDFH ; DJNZを使うので、B=0xf、C=0xDFにしている。Bがスキャン回数。Cがポート番号
CONTROL_SCAN_LOOP:
	INC C ; 初回の処理で、C=0xDF+1=0xE0となる。
	IN A,(C)
	LD (HL),A ; 値を、INIで入れたアドレスと同じところに格納する。
	INC HL ; メモリアドレスをインクリメント。
	DJNZ CONTROL_SCAN_LOOP ; 16回繰り返す

	LD HL,PORT_INDEX ; メモリアドレスポインタをPORT_INDEXの先頭に戻す。
	LD D,0H ; インデックスを 1 にする。
	LD B,0FH ; B=FH=16
	LD E,0H

;
; Controlキーを離すか、他のキーが押されるまではループする。
;

CONTROL_NEXT_KEY_LOOP:
	LD A, (PORT_INDEX)
	AND A
	LD A,1BH
	RET Z ; [EE00]=0、SHIFTキー押されてないならリターンする。
	INC HL
	INC D
	LD A, (HL) ; メモリアドレスからキースキャンの値を取り出す。
	AND A
	JR NZ, CONTROL_KEY_LOOP ; キーが押下されている時はジャンプする。
	LD A,D
	CP 0FH ; D=A=16バイトチェックしたか？
	JR Z, CONTROL_KEY_NEXT_GET ; 16バイト読み込んで、SHIFTキー以外何も押されていないなら、一番最初のループに戻る
	JR CONTROL_NEXT_KEY_LOOP ; 16バイト読んでないなら、次のメモリを読む。
	
CONTROL_KEY_LOOP:
	CP 08H
	JP Z, CODE_08_CONTROL
	CP 10H
	JP Z, CODE_10_CONTROL
	CP 20H
	JP Z, CODE_20_CONTROL


CODE_08_CONTROL:
	LD A,L
	AND 0FH

	CP 03H
	JP Z, CODE_E_CONTROL
	CP 04H
	JP Z, CODE_R_CONTROL
	CP 07H
	JP Z, CODE_U_CONTROL
	CP 0AH
	JP Z, CODE_P_CONTROL

CODE_10_CONTROL:
	LD A,L
	AND 0FH

	CP 02H
	JP Z, CODE_S_CONTROL

CODE_20_CONTROL:
	LD A,L
	AND 0FH

	CP 01H
	JP Z, CODE_Z_CONTROL
	CP 02H
	JP Z, CODE_X_CONTROL
	CP 03H
	JP Z, CODE_C_CONTROL

	LD A,0H
	RET


CODE_E_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 05H
	RET
CODE_C_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 03H
	RET
CODE_P_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 10H
	RET
CODE_R_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 12H
	RET
CODE_S_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 13H
	RET
CODE_U_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 15H
	RET
CODE_X_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 18H
	RET
CODE_Z_CONTROL:
	CALL KEY_BREAK_WAIT
	LD A, 1AH
	RET



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; SORD M68 memory
;

;
; for CRT control
;

CURSOR_LOCATE:
	DS 02H

TOP_VIEW:
	DS 02H

NEED_DO_SCROLL_POINT:
	DS 02H

CR_BASE_ADDRESS:
	DS 02H

CR_BASE_ADDRESS_PRE:
	DS 02H

CR_NOW_CURSOL_LOCATE:
	DS 02H

CR_NEW_ORIGIN:
	DS 02H

KEY_BUFFER:
	DS 0FH

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Keyboard map
;

KEY_MAP:
	DB 0H,'1234567890-=',5CH,08H,0H
	DB 0H,'QWERTYUIOP@',5BH,0DH,0DH,0H
	DB 0H,'ASDFGHJKL',3BH,3AH,5DH,0H,0H,0H
	DB 0H,'ZXCVB',20H,'NM',2CH,2EH,2FH,0H,0H,0H

;*****************************************************
;*                                                   *
;*	Unitialized RAM data areas		     *
;*                                                   *
;*****************************************************
;
sekdsk:		DS	1	;seek disk number
sektrk:		DS	2	;seek track number
seksec:		DS	1	;seek sector number
;
hstdsk:		DS	1	;host disk number
hsttrk:		DS	2	;host track number
hstsec:		DS	1	;host sector number
;
sekhst:		DS	1	;seek shr secshf
hstact:		DS	1	;host active flag
hstwrt:		DS	1	;host written flag
;
unacnt:		DS	1	;unalloc rec cnt
unadsk:		DS	1	;last unalloc disk
unatrk:		DS	2	;last unalloc track
unasec:		DS	1	;last unalloc sector
;
erflag:		DS	1	;error reporting
rsflag:		DS	1	;read sector flag
readop:		DS	1	;1 if read operation
wrtype:		DS	1	;write operation type
dmaadr:		DS	2	;last dma address
hstbuf:		DS	hstsiz	;host buffer
;
;	the remainder of the cbios is reserved uninitialized
;	data area, and does not need to be a Part of the
;	system	memory image (the space must be available,
;	however, between"begdat" and"enddat").
;
track:		DS	2	;two bytes for expansion
sector:		DS	2	;two bytes for expansion
dmaad:		DS	2	;direct memory address
diskno:		DS	1	;disk number 0-15
;
;	scratch ram area for bdos use
begdat	EQU	$	;beginning of data area
dirbf:		DS	128	;scratch directory area
all00:		DS	31	;allocation vector 0
all01:		DS	31	;allocation vector 1
all02:		DS	31	;allocation vector 2
all03:		DS	31	;allocation vector 3
chk00:		DS	16	;check vector 0
chk01:		DS	16	;check vector 1
chk02:		DS	16	;check vector 2
chk03:		DS	16	;check vector 3
;

;
; key input scan buffer
; 末尾1バイトのアドレスが00であることを期待していてる。
;
	org KEYBOARD_SCAN_BUFFER

PORT_INDEX:
	DS 16

; FDC_CONTROL_REGへのコマンドを保存しておく

fdc_control_command:
	DS 1

enddat	EQU	$	;end of data area
datsiz	EQU	$-begdat	;	;size of data area

	END
